PIFs are "Primitive Interface Functions".  They are functionalized version
of the primitives.

Primitives can be called within other primitives with this syntax:
   rc.run("primitive_name")

This will run "primitive_name" on all the astrodata objects in the 
current stream.

If one wants to run the primitive on a specific astrodata object, for 
example within a for-loop through the input astrodata object, then one
needs to use a function.  This is where the PIFs are useful.

Example:
  from pifghost import ghost_spect
  for ad in rc.get_inputs_as_astrodata():
      ghost_spect.primitive_name(ad)

The rc.run() tends to be speedier in benchmarks, so use that when you can
over the for-loop option.  But when a for-loop is necessary, use the 
PIF format.

See the "prepare" primitive in 
  astrodata_Gemini/RECIPES_Gemini/primitives/primitives_standardize.py
for an example of both forms.

-----

Creating the PIFs.

The creation of PIFs can be somewhat automated, though not fully.

The first step is to add the primitives one wants to create a PIF for in
the dictionary "primdics/pif2primDict.py".

Next, run "mkPIF" from the PIF_GHOST directory.  This will annoyingly 
add an "import pif" in the __init__.py.  Delete it.  There should only be
an "import pifghost".

Then copy the new PIFs from the "pif" directory to their proper location
in the "pifghost" directory.  It is not recommended to delete "pifghost"
and rename "pif" to "pifghost".  The reason is that it is recommended
to add docstrings to the PIFs and that is done manually.  Delete "pifghost"
and you delete all your docstrings.

A bit clunky, but PIF creation is not something one does everyday.  So,
it should be manageable.  Maybe one day we will have a smarter mkPIF but 
it isn't on the priority list for now.
-----

